<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .div1 {
            width: 50px;
            height: 50px;
            background-color: red;
        }
    </style>
</head>

<body>
    <div class="div1" id="div1"></div>
    <ul>
        <li>1知否知否，应是等你好久</li>
        <li>2知否知否，应是等你好久</li>
        <li>3知否知否，应是等你好久</li>
        <li>4知否知否，应是等你好久</li>
        <li>5知否知否，应是等你好久</li>
    </ul>
    <ol id="ol">
        <li>ol1</li>
        <li>ol2</li>
        <li>ol3</li>
    </ol>
    <input type="button" value="按钮" id="btn">
    <hr><br>
    <div class="div-button-list">
        <button>按钮1</button>
        <button>按钮2</button>
        <button>按钮3</button>
        <button>按钮4</button>
        <button>按钮5</button>
    </div>
    <div>父元素
        <div class="div2">div2</div>
        <div class="div3">div3</div>
    </div>
    <div class="div4">div4</div>
    <div class="div5">
        <input type="text">
        <p></p>
    </div>

    <style>
        table,
        td {
            border: 1px solid #333;
        }

        thead,
        tfoot {
            background-color: skyblue;
            color: blue;
        }

        thead th {
            color: black;
            font-weight: 700;
        }

        tbody {
            color: blue;
            text-align: center;
        }
    </style>
    <table class="table">
        <thead>
            <tr>
                <th colspan="">代码</th>
                <th colspan="">名称</th>
                <th colspan="">最新公布净值</th>
                <th colspan="">累计净值</th>
                <th colspan="">前单位净值</th>
                <th colspan="">净值增长率</th>
            </tr>
        </thead>
        <tbody class="tbody" index-data="这是自定义属性">
            <tr>
                <td>003526</td>
                <td>农银行金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银行金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银行金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银行金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银行金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银行金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
        </tbody>
    </table>

    <!-- tab栏切换布局 -->
    <style>
        .tab {
            width: 800px;
            height: 400px;
            border: 1px solid black;
        }

        .tab-list ul {
            display: flex;
            /* flex-direction: row; */
            justify-content: space-around;
            list-style: none;
        }

        .tab-list li {
            line-height: 50px;
            text-align: 50px;
            font-weight: 700;
            cursor: pointer;
        }

        /* .li1 {
            background-color: red;
            color: white;
        } */

        .li-onck {
            background-color: red;
            color: white;
        }

        .tab-con div:not(:nth-child(1)) {
            display: none;
        }
    </style>
    <div class="tab">
        <div class="tab-list">
            <ul>
                <li class="li-onck">商品介绍</li>
                <li>规格与包装</li>
                <li>售后保障</li>
                <li>商品评价（5000）</li>
                <li>手机社区</li>
            </ul>
        </div>
        <div class="tab-con">
            <div>1 商品介绍模块内容</div>
            <div>2 规格与包装模块内容</div>
            <div>3 售后保障模块内容</div>
            <div>4 商品评价模块内容</div>
            <div>5 手机社区模块内容</div>
        </div>
    </div>
    <script>
        var tab_list_li = document.querySelector(".tab-list").querySelectorAll("li");
        var tab_cons = document.querySelector(".tab-con").querySelectorAll("div");
        console.log("tab_list_li");
        console.log(tab_list_li);
        console.log(tab_cons);
        // console.log(Array.isArray(tab_list_li));
        tab_list_li = Array.from(tab_list_li);
        tab_cons = Array.from(tab_cons);
        console.log(tab_list_li);
        console.log(tab_cons);
        tab_list_li.forEach((element, index) => {
            element.onclick = () => {
                tab_list_li.forEach((element, index) => {
                    // element.className=""; //改变原来class
                    element.classList.remove("li-onck"); //从class移除 li-onck 选中的样式
                    tab_cons[index].style.display = "none"; //tab-con所有内容块不显示
                })
                element.classList.add("li-onck");//不改变原来的class class列表中新增
                element.setAttribute("data-index", index) //给li添加index属性 值为li数组索引
                tab_cons[index].style.display = "block"; //根据li的index 显示对于的con块

            }
        })
    </script>
    <!-- ↑js部分↑ -->






    <div>
        <ul class="c-ul">创建节点和添加节点
            <li>原节点</li>
        </ul>
    </div>
    <script>
        //1 创建节点元素节点
        var li = document.createElement("li");
        li.innerHTML = "<strong>新创建的li节点</strong>"
        // console.log("li");
        // console.log(li);
        //2 添加节点 node.appendChile(child) node 父级 child 子级
        var ul = document.querySelector(".c-ul");
        // console.log(ul);
        //3 把创建的节点添加进父级的孩子集里
        ul.appendChild(li);  //该方法将节点添加到列表的末尾，类似css的::after伪元素
        console.log(ul);
        console.log("ulchildren");
        console.log(ul.children);
        //4 删除节点
        ul.removeChild(ul.children[0]);
    </script>




    <div>
        <div class="erweima E2" id="erweima">节点</div>
        <div>div1</div>
        <div>div2</div>
        <div>div3</div>
    </div>

    <div>
        <div class="d-clone">111
            <div>111.1</div>
            <div>111.2</div>
        </div>
        <div>222</div>
        <div>333</div>
    </div>










    <!-- 动态生成表格 -->
    <style>
        .tb thead {
            background-color: gray;
            border: 1px solid black;
        }
    </style>
    <table class="tb">
        <thead>
            <th>姓名</th>
            <th>科目</th>
            <th>成绩</th>
            <th>操作</th>
        </thead>
        <tbody class="tb-l">
        </tbody>
        <script>
            var student = [{
                name: "小明",
                subject: "JavaScript",
                score: "100"
            },
            {
                name: "小李",
                subject: "JavaScript",
                score: "90"
            },
            {
                name: "小天",
                subject: "JavaScript",
                score: "80"
            },
            {
                name: "小手",
                subject: "JavaScript",
                score: "70"
            },
            {
                name: "小魏",
                subject: "JavaScript",
                score: "60"
            }]
            var tb_l = document.querySelector(".tb-l");
            //遍历student对象
            student.forEach((element) => { //element是student数组的每个对象
                // console.log(element);
                var tr = document.createElement("tr");
                // console.log("tr");
                // console.log(tr);
                tb_l.appendChild(tr); //插入tr节点
                for (const key in element) { //遍历对象的属性
                    // console.log(key);
                    var td = document.createElement("td");
                    tr.appendChild(td);
                    td.innerText = element[key]; //给td插入数据 student数组里对象的值
                }
                var del = document.createElement("td");
                tr.appendChild(del);
                del.innerHTML = '<a href="javascript:void(0)">删除</a>';
                del.onclick = element => {
                    tr.remove();  //删除tr节点
                }
            })
            // tb_l = Array.from(tb_l);
            // tb_l.forEach((element) => {
            //     // console.log(element);
            //     var del = element.lastElementChild; //
            //     a.style.cursor = "pointer";
            //     // console.log(element.querySelector("a"));
            //     a.onclick = () => {
            //         element.remove(); //监听a点击事件 删除节点
            //     }
            // })
        </script>
    </table>





    <button class="btn-l">addEventListener 添加事件监听器</button>

    <p>阻止链接跳转默认行为</p>
    <a class="a-p" href="https://www.baidu.com/">百度</a>

    <ul class="ul-e">事件委托,注册ul,点击li利用冒泡触发ul的事件
        <li>li1</li>
        <li>li2</li>
        <li>li3</li>
    </ul>

    <style>
        .m-info {
            border: 1px solid black;
            width: 280px;
            height: 150px;
            position: fixed;
            top: 50%;
            right: 0;
        }
    </style>
    <div class="m-info">
        <p>鼠标事件 </p>
        <p>鼠标位置
            <br>
            窗口可视区x:&nbsp&nbsp<span class="m-cx">cx</span>
            窗口可视区y:&nbsp&nbsp<span class="m-cy"></span>
            <br>
            文档页面x:&nbsp&nbsp<span class="m-px"></span>
            文档页面y:&nbsp&nbsp<span class="m-py"></span>
            <br>
            电脑屏幕x:&nbsp&nbsp<span class="m-sx"></span>
            电脑屏幕y:&nbsp&nbsp<span class="m-sy"></span>
        </p>
    </div>

    
    <style>
        .B{
            width: 200px;
            height: 100px;
            position: relative;

        }
        .B-input{
            position: absolute;
            top: 50px;
        }
        .con{
            width: 171px;
            height: 30px;
            border: 1px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            padding: 5px 0;
            font-size: 18px;
            line-height: 20px;
            color: #333;
            position: absolute;
        }
        .con::before{
            content: "";
            width: 0;
            height: 0;
            position: absolute;
            top: 40px;
            left: 15px;
            border: 8px solid black;
            border-style: solid dashed dashed;
            border-color: rgb(255, 255, 255) transparent transparent;
        }
    </style>
    <div class="B">
        <div class="con">123</div>
        <input type="text" class="B-input" placeholder="输入您的快递单号">
    </div>

    <br>
    <br>
    <br>



</body>























<script>

    // 1.1 id获取元素对象 doucument.getElementByld('id名')

    // 1.2 标签名获取元素对象 doucument.getElementsByTagName('标签名');
    //     因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历
    //     得到元素对象是动态的
    //     返回的是获取过来元素对象的集合，以伪数组的形式存储
    //     如果获取不到元素，则返回为空的伪数组(因为获取不到对象)

    var lis = document.getElementsByTagName('li');
    console.log(lis);
    console.log(lis[2]);
    lis[2].style.backgroundColor = "#cccccc"

    // 1.3 标签名获取某个元素内部所有指定标签名的子元素,获取的时候不包括父元素自己
    //      注意：父元素必须是单个对象(必须指明是哪一个元素对象)，获取的时候不包括父元素自己
    //      不能直接使用ol.获取，bytagname返回的是伪数组，要用ol.[0]来获取子元素
    var ol = document.getElementsByTagName('ol');
    console.log("l52↓");
    console.log(ol);
    console.log(ol[0].getElementsByTagName('li'));
    var ol_li = ol[0].getElementsByTagName('li');
    ol_li[1].style.backgroundColor = "#cccccc"
    //      可以直接给ol标签加id 通过id获取单个对象
    var ol2 = document.getElementById("ol");
    var ol2_li = ol2.getElementsByTagName("li");
    console.log(ol2_li);


    //H5新增
    //2.1 根据类名返回元素对象合集 document.getElementsByClassName('类名')
    //2.2 根据指定选择器返回第一个元素对象 document.querySelector('选择器')
    //2.2 根据指定选择器返回所有元素对象 document.querySelectorAll('选择器');

    var div1 = document.querySelector(".div1"); //返回符合选择器的第一个元素
    // 切记 里面的选择器需要加符号 .box  #nav
    console.log(div1);
    div1.style.width = "100px";
    div1.style.height = "100px";
    div1.style.backgroundColor = "skyblue";

    //获取特殊元素
    //3.1 返回body元素对象 document.body;
    //3.2 返回html元素对象 document.documentElement;

    // 0.1+0.2 不等于0.3!!!
    console.log((0.1 + 0.2) == 0.3); //false
    console.log(0.1 + 0.2); //0.30000000000000004

    //事件
    // 点击一个按钮，弹出对话框
    // 1. 事件是有三部分组成  事件源  事件类型  事件处理程序   我们也称为事件三要素

    //(1) 事件源 事件被触发的对象   谁  按钮
    var btn = document.getElementById('btn');
    //(2) 事件类型  如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下
    //(3) 事件处理程序  通过一个函数赋值的方式 完成
    btn.onclick = () => {
        alert('点秋香');
    };


    //按钮点击交互
    var btn = document.querySelector(".div-button-list").children; //获取按钮父元素下的子元素数组
    // btn[1].style.backgroundColor = "pink"
    // for (let i = 0; i < btn.length; i++) {
    //     btn[i].onclick = () => { //点击事件 清除所有的背景色 然后单独给当前按钮设置背景色
    //         for (let i = 0; i < btn.length; i++) {
    //             btn[i].style.backgroundColor = ""; //遍历清除全部的bgcolor
    //         }
    //         btn[i].style.backgroundColor = "pink"
    //     }
    // }


    //forEach 实现上面效果
    var btns = Array.from(btn);
    var btns1 = Array(btn);
    //Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。 将类数组对象转换为真正数组
    console.log("btns");
    console.log(btns);
    console.log(btn);
    console.log(btns1);
    console.log(Array.isArray(btns));
    console.log(Array.isArray(btn));
    console.log(Array.isArray(btns1));
    console.log(Array.isArray(btns1[0]));
    console.log(btns1[0]);
    btns.forEach(element => {
        element.onclick = () => {
            btns.forEach(element => {
                element.style.backgroundColor = "";
            });
            element.style.backgroundColor = "pink"
        }
    });




    // console.log("btn");
    // console.log(btn);

    // onclick	鼠标点击左键触发
    // onmouseover	鼠标经过触发
    // onmouseout	鼠标离开触发
    // onfocus	获得鼠标焦点触发
    // onblur	失去鼠标焦点触发
    // onmousemove	鼠标移动触发
    // onmouseup	鼠标弹起触发
    // onmousedown	鼠标按下触发


    // innerText 和 innerHTML的区别 
    // 1. innerText 不识别html标签,去除空格和换行
    var div2 = document.querySelector('.div2');
    var div3 = document.querySelector('.div3'); 3
    div2.innerText = "innerText"; //把标签里面的内容改了
    // 2. innerHTML 识别html标签 保留空格和换行的
    div3.innerHTML = '<strong>今天是：</strong> ' + new Date();
    // 这两个属性是可读写的  可以获取元素里面的内容

    var par = div2.parentNode; //获取div2的父元素节点
    par.style.backgroundColor = "skyblue"
    // par.innerText="asdasd"
    console.log(par);
    console.log(par.innerText);
    console.log(par.innerHTML);


    //改变img属性
    // img.src = "xxx";

    // input.value = "xxx";
    // input.type = "xxx";
    // input.checked = "xxx";
    // input.selected = true / false;
    // input.disabled = true / false

    // element.style
    // js改变的样式是行内样式
    //div.style.backgroundColor = 'pink';
    //div.style.width = '250px';

    // JS里面的样式采取驼峰命名法，比如 fontSize ，backgroundColor
    // JS 修改 style 样式操作 ，产生的是行内样式，CSS权重比较高
    // 如果样式修改较多，可以采取操作类名方式更改元素样式
    // class 因为是个保留字，因此使用className来操作元素类名属性
    // className 会直接更改元素的类名，会覆盖原先的类名
    // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用

    var test = document.querySelector('.div4');
    test.onclick = function () {
        this.style.backgroundColor = 'purple';
        this.style.color = '#fff';
        this.style.fontSize = '25px';
        this.style.marginTop = '100px';
        //让我们当前元素的类名改为了 change

        // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
        // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
        // this.className = 'change';
        var cname = this.className;
        console.log(cname);
        this.className = "fitst change";
    }


    //操作表单元素
    var inp = document.querySelector(".div5").querySelector("input");
    console.log(inp);

    // inp.onchange = () => { //改变事件
    //     var inp_text = inp.value;
    //     // console.log(inp_text);
    //     var p_text = inp.parentElement.querySelector("p");
    //     // console.log(p_text);
    //     p_text.innerText = inp_text;
    // }
    inp.addEventListener("input", (e) => { //添加事件监听器 类型为input,触发事件
        p = inp.parentElement.querySelector("p");
        // console.log(e.srcElement);
        // console.log(e);
        p.textContent = e.srcElement.value;
        // console.log(e.srcElement.value);
    })


    //forEach 遍历数组
    var arr4 = ['a', 'b', 'c'];
    arr4.forEach((value, index, array) => {
        console.log(value);
        console.log(index);
        console.log(array);
    });

    //表格table js实现hover效果
    var tbody = document.querySelector(".tbody");
    // console.log(tbody);
    var tr = tbody.children;
    // console.log(tr);
    tr = Array.from(tr); //转成数组 方便使用forEach
    tr.forEach(element => {
        element.onmouseover = () => {
            element.style.backgroundColor = "#DDF1FF";
        }
        element.onmouseout = () => {
            element.style.backgroundColor = "";
        }
    })

    console.log(tbody.getAttribute("index-data"));
    tbody.setAttribute("index-data1", "设置修改自定义属性"); //修改或新增属性
    console.log(tbody.getAttribute("index-data1"));
    tbody.dataset.index3 = "h5自定义属性";
    tbody.dataset.h5DivAtt = "h5DivAtt";
    tbody.dataset["listNameCon"] = "listNameCon";



    //获取元素属性 
    //  获取内置属性 id class 等 element.属性;
    //  获取自定义属性
    //      兼容性获取:element.getAttribute('属性');
    //          自定义属性如下: element.getAttribute('index-data')
    //          <div index-data="1"></div>
    //      H5新增:element.dataset.index 或element.dataset['index'] IE11才开始支持
    //          自定义属性如下: element.dataset.h5DivAtt="h5DivAtt" / element.dataset['h5DivAtt']
    //          <div data-h5-div-att="H5自定义属性"></div>
    //设置属性
    //  设置内置属性 element.属性 = '值';
    //  设置自定义的属性 element.setAttribute('属性','值');
    //移除属性 element.removeAttribute('属性');



    //节点
    //  节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性
    //      元素节点：nodeType 为1
    //      属性节点：nodeType 为2
    //      文本节点：nodeType 为3(文本节点包括文字、空格、换行等)
    //父节点 node.parenNode
    //  parentNode属性可以返回某节点的父结点，注意是最近的一个父结点
    //  如果指定的节点没有父结点则返回null
    // var e2 = document.querySelector('.erweima.E2');
    // e2.parentElement;
    // console.log(e2);
    // console.log(erweima.parentNode); //兼容高
    // console.log(e2.parentElement); //ie9
    //子节点
    //  parentNode.childNodes
    //      parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合
    //      返回值包含了所有的子结点，包括元素节点，文本节点等
    //      如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes
    // !!! parentNode.children  !!!
    //      parentNode.children 是一个只读属性，返回所有的子元素节点
    //      它只返回子元素节点，其余节点不返回 （这个是我们重点掌握的）
    //  parentNode.firstElementChild
    //      firstElementChild 返回第一个子节点，找不到则返回null
    //      有兼容性问题，IE9以上才支持
    //  parentNode.lastElementChild
    //      lastElementChild 返回最后一个子节点，找不到则返回null
    //      有兼容性问题，IE9以上才支持
    //  获取子节点推荐用 parentNode.chilren[0] 解决兼容性问题
    //      parentNode.chilren[0] 获取第一个子节点
    //      parentNode.chilren[parentNode.chilren.length - 1]
    var e2 = document.querySelector('.erweima.E2');
    var e2Parent = e2.parentNode;
    //  e2Parent.children[-1];
    //  console.log(e2Parent.children[e2Parent.children.length - 1]); 
    //  获取e2Parent下的最后一个子元素节点
    //兄弟节点
    //  node.nextSibling
    //      nextSibling 返回当前元素的下一个兄弟节点!，找不到则返回null
    //      包括文本节点在内，也就是标签间的文本和回车！！！
    //  node.previousSibling
    //      previousSibling 返回当前元素上一个兄弟节点!，找不到则返回null
    //      包括文本节点在内，也就是标签间的文本和回车！！！
    //！！！推荐用下面的！！！
    // !! node.nextElementSibling
    //      nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null
    //      有兼容性问题，IE9才支持
    // !! node.previousElementSibling
    //      previousElementSibling 返回当前元素上一个兄弟元素节点，找不到则返回null
    //      有兼容性问题，IE9才支持
    var e3 = e2.nextSibling;
    console.log(e3);
    var e4 = e2.nextElementSibling;
    console.log(e4);

    // 克隆节点 深/浅拷贝
    //node.cloneNode()
    //      node.cloneNode()方法返回调用该方法的节点的一个副本。 也称为克隆节点/拷贝节点
    //      如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点
    //      如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点
    //
    let d = document.querySelector(".d-clone");
    let d1 = d.cloneNode(false); //浅拷贝 只拷贝元素节点 没有值
    let d2 = d.cloneNode(true);  //深拷贝 把自己所有内容都拷贝，包括值和子节点
    console.log(d1);
    console.log(d2);


    //三种动态创建元素的区别
    //     doucument.write()
    //     element.innerHTML
    //     document.createElement()
    // 区别
    //  document.write() 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘 不推荐！
    //  innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘
    //            创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
    //  createElement()创建多个元素效率稍低一点点，但是结构更清晰



    //事件
    //  给元素添加事件，称为注册事件或者绑定事件
    //  注册事件有两种方式：传统方式和方法监听注册方式

    //     传统注册方式	                                        方法监听注册方式
    // 利用 on 开头的事件 onclick	                            w3c 标准推荐方式
    // <button onclick = "alert("hi")"></button>	        addEventListener() 它是一个方法
    // btn.onclick = function() {}	                IE9 之前的 IE 不支持此方法，可使用 attachEvent() 代替
    // 特点：注册事件的唯一性	                        特点：同一个元素同一个事件可以注册多个监听器
    // 同一个元素同一个事件只能设置一个处理函数，	                按注册顺序依次执行
    // 最后注册的处理函数将会覆盖前面注册的处理函数

    //addEventListener事件监听方式
    //      eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上
    //      当该对象触发指定的事件时，就会执行事件处理函数
    // 1 eventTarget.addEventListener(type,listener[,useCapture])
    //      type:事件类型字符串，比如click,mouseover,注意这里不要带on
    //      listener：事件处理函数，事件发生时，会调用该监听函数
    //      useCapture：可选参数，是一个布尔值，默认是 false,和DOM事件流相关
    //removeEventListener删除事件方式
    //      eventTarget.removeEventListener(type,listener[,useCapture]);
    //      type:事件类型字符串，比如click,mouseover,注意这里不要带on
    //      listener：事件处理函数，把处理函数移除出监听的事件
    var btn_l = document.querySelector(".btn-l");
    btn_l.addEventListener("click", () => {
        alert("事件监听已添加");

    });
    //事件监听的方式 同一元素同一事件按顺序执行，不会被覆盖
    fn2 = () => {
        alert("事件监听2");
        btn_l.removeEventListener("click", fn2);
    };
    function fn3() {
        alert("事件监听3");

    }
    btn_l.addEventListener("click", fn2);
    btn_l.addEventListener("click", fn3);
    //事件删除 解绑
    btn_l.removeEventListener("click", fn3);





    var input = document.createElement("input");
    var p2 = document.createElement("p");
    //input.setAttribute("type","text");
    console.log(input);
    var body = document.querySelector("body");
    console.log(body);
    // body.appendChild(input);
    body.append(input, p2);
    // body.appendChild(p2);
    input.oninput = () => {
        p2.innerHTML = input.value;
    }
    // btn_l.addEventListener();
    var arrt = [3, 5, 7];
    arrt.foo = "hello";
    console.log(arrt);
    console.log(arrt["foo"]);




    //for in遍历下标索引 和键
    for (const key in arrt) {
        if (Object.hasOwnProperty.call(arrt, key)) {
            console.log(key);
        }
    }
    //for of遍历数组元素的值 只有索引对应的值 不包括键的值
    for (const iterator of arrt) {
        console.log(iterator);
    }

    function myConcat(separator) {
        var result = ''; // 把值初始化成一个字符串，这样就可以用来保存字符串了！！
        var i;
        // iterate through arguments
        for (i = 1; i < arguments.length; i++) {
            result += arguments[i] + separator;
        }
        console.log(arguments); //可以用遍历对象的for in 遍历arguments
        for (const key in arguments) {
            const element = arguments[key];
            console.log(key);
            console.log(element);
        }
        return result;
    }

    //DOM 事件流
    //  事件流描述的是从页面中接收事件的顺序
    //  事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流
    //DOM事件流分三个阶段
    //  给div注册事件 
    //1 捕获阶段 由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程
    //  从document->html->body->div,事件发生时，从文档最开始往下传播进行捕获，直到捕获到目标div
    //  先看 document 的事件，没有；再看 html 的事件，没有；再看 body 的事件，没有；
    //  再看 father 的事件，有就先执行；再看 son 的事件，再执行。
    //
    //2 当前目标阶段
    //  
    //3 冒泡阶段 从目标阶段往上冒泡到DOM顶层节点，div->html->body->document
    //      冒泡阶段开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点
    //  
    // 捕获和冒泡是传播方向不同，两个阶段都会事件传播，
    //
    //  onclick 和 attachEvent（ie） 只能得到冒泡阶段。
    //  捕获阶段 addEventListener 第三个参数是 true 那么则处于捕获阶段
    //  冒泡阶段 addEventListener 第三个参数是false 
    //      addEventListener默认是false，冒泡阶段
    //
    //  父div和子div都有点击事件，如果事件是捕获阶段，
    //     当点击子div时，会先执行父div的事件处理函数再执行子div的
    //  冒泡阶段则反之，先执行子div再执行父div处理函数
    //
    //  实际开发中我们很少使用事件捕获，我们更关注事件冒泡
    //  有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave

    //事件对象
    btn_l.onclick = function (event) {
        console.log(this);
        console.log(event);
        console.log(event.target);
    }; //这个event 形参就是事件对象
    //事件对象有事件才存在，系统自动创建，不需要传递参数，事件无参时也会生成event
    //event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态
    //  事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面
    //  这个对象就是事件对象 event，它有很多属性和方法，比如
    //      谁绑定了这个事件
    //      鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置
    //      键盘触发事件的话，会得到键盘的相关信息，如按了哪个键
    // 兼容性
    // 事件对象 ie678 只能使用 window.event得到事件对象
    // 兼容性写法 event = event || window.event;


    //事件对象的常见属性和方法
    // e.target	            返回触发事件的对象 标准
    // e.srcElement	        返回触发事件的对象 非标准 ie6-8使用
    // e.type	            返回事件的类型 比如click mouseover 不带on
    // e.cancelBubble	    该属性阻止冒泡，非标准，ie6-8使用
    // e.returnValue	    该属性阻止默认行为 非标准，ie6-8使用
    // e.preventDefault()	该方法阻止默认行为 标准 比如不让链接跳转
    // e.stopPropagation()	阻止冒泡 标准


    //
    // e.target 和 this 区别
    //  e.target 是事件触发的元素。
    //  this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）
    //  如 给ul绑定了点击事件
    //      点击ul下的li会触发ul的事件
    //      此时this返回绑定事件的ul
    //      e.target返回触发事件的li

    //事件对象阻止默认行为
    //e.preventDefault(); //  dom 标准写法
    var a_p = document.querySelector(".a-p");
    a_p.addEventListener("click", e => {
        console.log(e);
        e.preventDefault()// 阻止默认行为 a链接无法跳转
    })

    //阻止事件冒泡
    //  事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点
    //  e.stopPropagation(); 标准写法
    //  e.cancelBubble = true; 非标准写法： IE6-8 利用对象事件 cancelBubble属性
    //阻止事件冒泡的兼容性解决方案
    // if(e && e.stopPropagation){
    // e.stopPropagation(); 
    //     e.stopPropagation();
    // } else {
    //     window.event.cancelBubble = true;
    // }



    //事件委托/委派/代理
    //  事件委托也称为事件代理，在 jQuery 里面称为事件委派
    //  事件委托的原理
    //!!!不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点
    // 如 ul里面很多的li列表 给ul注册点击事件，利用事件对象e.target得到触发的li
    //  因为点击li，事件会冒泡到ul上,ul有注册事件，就会触发事件监听器,执行处理函数
    //事件委托，只操作一次dom，提高程序性能

    // 利用事件冒泡通过li触发ul事件 这就是事件委托
    var ul_e = document.querySelector(".ul-e");
    ul_e.addEventListener("click", function (e) {
        alert(e.target.textContent);
        // console.log(this.children);
        for (k in this.children) {
            if (this.children[k].nodeType == 1) { //判断ul_e子节点集合里的元素节点
                console.log(this.children[k]);
                this.children[k].style.backgroundColor = "";
            }
            e.target.style.backgroundColor = "pink";
        }

    })

    //鼠标事件对象
    //e.clientX         返回鼠标相对于浏览器窗口可视区的X坐标
    //e.clientY	        返回鼠标相对于浏览器窗口可视区的Y坐标
    //e.pageX（重点）	返回鼠标相对于文档页面的X坐标 IE9+ 支持
    //e.pageY（重点）	返回鼠标相对于文档页面的Y坐标 IE9+ 支持
    //e.screenX	        返回鼠标相对于电脑屏幕的X坐标
    //e.screenY	        返回鼠标相对于电脑屏幕的Y坐标


    //获取鼠标事件对象 位置
    var m_cx = document.querySelector(".m-cx");
    var m_cy = document.querySelector(".m-cy");
    var m_px = document.querySelector(".m-px");
    var m_py = document.querySelector(".m-py");
    var m_sx = document.querySelector(".m-sx");
    var m_sy = document.querySelector(".m-sy");
    // console.log(m_cx);
    document.addEventListener("mousemove", (e) => {
        m_cx.textContent = e.clientX;
        m_cy.textContent = e.clientY;
        m_px.textContent = e.pageX;
        m_py.textContent = e.pageY;
        m_sx.textContent = e.screenX;
        m_sy.textContent = e.screenY;
    })

    //常用键盘事件
    //onkeyup	    某个键盘按键被松开时触发
    //onkeydown	    某个键盘按键被按下时触发
    //onkeypress	某个键盘按键被按下时触发，但是它不识别功能键，比如 ctrl shift 箭头等
    //如果使用addEventListener 不需要加 on
    //三个事件的执行顺序是： keydown – keypress — keyup
    //键盘事件对象属性
    //keyCode       返回该键值的ASCII值
    //key           返回键名 输入什么返回什么

    document.addEventListener("keydown", e => {
        //  console.log(e.key);
    })

    //模拟快递单号查询
    var b_input = document.querySelector(".B-input");
    var con = document.querySelector(".con");
    b_input.addEventListener("input",()=>{
        con.innerText = b_input.value;
    })












</script>

</html>